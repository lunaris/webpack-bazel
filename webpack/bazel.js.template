const path = require("path");

module.exports = function (cfg) {
  return function (env, argv) {
    let cfgObject;
    switch (typeof cfg) {
      case "function":
        cfgObject = cfg(env, argv);
        break;
      case "object":
        cfgObject = cfg;
        break;
      default:
        throw `Cannot Bazel-ify configurations of type ${typeof cfg}`;
    }

    const bazelConfiguration = {
      output: {
        path: path.resolve(TEMPLATED_path)
      },
      resolveLoader: {
        modules: TEMPLATED_loader_workspaces
          .map(ws => path.resolve(process.env.RUNFILES, ws, "node_modules"))
      },
      resolve: {
        modules: [...TEMPLATED_dep_workspaces, ...TEMPLATED_plugin_workspaces]
          .map(ws => path.resolve(`external/${ws}/node_modules`))
      }
    };

    process.env.PATH = [...TEMPLATED_tool_paths, process.env.PATH].join(":");

    return Object.assign(cfgObject, bazelConfiguration);
  };
};
